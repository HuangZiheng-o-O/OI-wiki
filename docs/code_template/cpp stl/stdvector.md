##  `std::vector` 

`std::vector` 是 C++ 标准模板库 (STL) 中的一种动态数组容器，其本质是对 C 风格动态数组的抽象和封装。尽管标准未明确要求 `std::vector` 必须采用动态数组的实现，但其操作复杂度和特性暗示了动态数组是其主要实现方式。

## 1. **基本概念**

#### 动态数组的特性

- **动态扩展能力**：`std::vector` 可以根据需求动态调整大小，而无需用户手动管理内存。
- **顺序存储**：所有元素按照插入顺序存储在连续内存空间中。

#### 定义与用法

使用 `std::vector` 需要引入头文件：

```cpp
#include <vector>
```

在 `std` 命名空间中，`std::vector` 是一个类模板，定义如下：

```cpp
namespace std {
    template <typename T, typename Allocator = allocator<T>>
    class vector;
}
```

- `T`：表示存储元素的类型。
- `Allocator`：表示内存分配策略，默认使用 C++ 标准库提供的 `allocator`。

## 2. **`std::vector` 的核心能力**

#### 有序集合

- 元素总是按照插入顺序存储，因此它是一个有序容器。

`std::vector` 是 C++ 标准模板库（STL）中的动态数组容器，提供了多种操作。以下是常用操作及其时间复杂度的总结：

- **随机访问**：通过下标或迭代器访问任意元素，时间复杂度为 O(1)。
- **在末尾插入元素**：使用 `push_back()` 方法，平均时间复杂度为 O(1)。然而，当 `vector` 容量不足时，需要重新分配内存并复制元素，此时操作的时间复杂度可能升高，但由于扩容通常按倍数增加，摊销后仍为 O(1)。 citeturn0search2
- **在末尾删除元素**：使用 `pop_back()` 方法，时间复杂度为 O(1)。
- **在中间或开头插入元素**：使用 `insert()` 方法，时间复杂度为 O(n)，因为需要移动插入位置之后的所有元素以腾出空间。
- **在中间或开头删除元素**：使用 `erase()` 方法，时间复杂度为 O(n)，因为需要移动删除位置之后的所有元素以填补空缺。
- **查找元素**：如果未排序，需要线性搜索，时间复杂度为 O(n)。如果已排序，可使用二分查找，时间复杂度为 O(log n)。

需要注意的是，`std::vector` 的某些操作可能导致迭代器失效，特别是在插入、删除或扩容时。

因此，在执行这些操作后，应谨慎使用先前获取的迭代器。

在选择容器时，应根据具体需求考虑操作的频率和类型。

例如，如果需要频繁在中间插入或删除元素，`std::list` 可能更适合，因为它在这些操作上的时间复杂度为 O(1)。

而如果主要需求是快速随机访问和在末尾插入或删除元素，`std::vector` 则是更好的选择。 citeturn0search0



## 3. **容量与大小**

#### `size` 与 `capacity`

- `size()`：返回当前元素的数量。
- `capacity()`：返回当前分配的内存能容纳的元素数量。

**容量机制**：

1. 为提升性能，`std::vector` 通常会预分配比实际所需更大的内存空间，以减少频繁的内存分配开销。
2. 超过当前 `capacity()` 时，`std::vector` 会重新分配更大的内存块并移动所有元素（性能代价较高）。

####  重新分配的影响

- 重新分配内存会使所有迭代器、指针和引用失效。因此，在性能关键的程序中，需谨慎操作容量以减少重新分配的发生。

## 4. **构造函数与析构函数**

`std::vector` 提供多种构造方式，便于灵活初始化：

| 构造函数形式                | 描述                                                   |
| --------------------------- | ------------------------------------------------------ |
| `vector<Elem> c;`           | 默认构造函数，创建空向量                               |
| `vector<Elem> c(c2);`       | 拷贝构造函数，复制向量 `c2`                            |
| `vector<Elem> c(n);`        | 创建含有 `n` 个默认构造元素的向量                      |
| `vector<Elem> c(n, elem);`  | 创建含有 `n` 个值为 `elem` 的元素的向量                |
| `vector<Elem> c(initlist);` | 使用初始化列表（如 `{1, 2, 3}`）创建向量（C++11 引入） |
| `vector<Elem> c(beg, end);` | 创建含有区间 `[beg, end)` 内元素的向量                 |

**析构函数**：

- 调用时会销毁所有元素并释放分配的内存。

### **深入探讨 `std::vector` 的性能优化与操作细节**

在实际使用中，`std::vector` 的性能表现和正确性很大程度上取决于对其内存管理和操作特性的理解。

------

## 1. **性能优化方法**

#### **1.1 预分配容量**

- 动态扩展的代价主要在于：
  1. 重新分配内存。
  2. 移动现有元素到新的内存位置。

为避免频繁的重新分配，可以使用 `reserve()` 提前预留足够的容量。示例：

```cpp
std::vector<int> v;
v.reserve(1000); // 确保容量足够容纳 1000 个元素，避免重复分配内存
for (int i = 0; i < 1000; ++i) {
    v.push_back(i);
}
```

#### **1.2 减少多余的内存**

如果需要将 `std::vector` 中未使用的内存回收，可以使用以下方法：

1. **C++11 提供的 `shrink_to_fit()` 方法**：

   ```cpp
   v.shrink_to_fit(); // 请求缩减容量至当前元素大小
   ```

   这是非强制的，具体效果依赖实现。

2. **手动实现缩减**（适用于 C++11 之前的版本）： 利用拷贝构造和交换操作，强制实现缩减：

   ```cpp
   std::vector<int>(v).swap(v); // 构造新向量并与原向量交换
   ```

   该操作会使所有指针、引用和迭代器失效。

------

## 2. **迭代器与失效问题**

#### **2.1 迭代器的有效性**

`std::vector` 在以下情况下会导致迭代器失效：

- **内存重新分配**： 当容量超过 `capacity()` 时，所有迭代器、指针、引用都会失效。
- **元素插入或删除**：
  - 在末尾操作（如 `push_back()`、`pop_back()`），仅会影响尾部迭代器。
  - 在中间或头部插入/删除，影响的是插入点之后的所有迭代器。

#### **2.2 失效的例子**

```cpp
std::vector<int> v = {1, 2, 3};
auto it = v.begin(); // 指向第一个元素
v.push_back(4); // 如果重新分配内存，`it` 将变为无效
```

为避免迭代器失效：

- 可通过 `reserve()` 提前分配足够内存。
- 重新分配后需重新获取迭代器。

------

## 3. **插入和删除操作**

#### **3.1 插入**

插入元素的方法包括：

1. **在末尾插入**：

   ```cpp
   v.push_back(10); // 在末尾插入元素 10
   ```

   性能为 `O(1)`（若无重新分配）。

2. **在指定位置插入**：

   ```cpp
   v.insert(v.begin() + 1, 20); // 在第二个位置插入 20
   ```

   性能为 `O(n)`，因为插入点后的所有元素需向后移动。

#### **3.2 删除**

删除操作包括：

1. **从末尾删除**：

   ```cpp
   v.pop_back(); // 删除最后一个元素
   ```

   性能为 `O(1)`。

2. **从指定位置删除**：

   ```cpp
   v.erase(v.begin() + 1); // 删除第二个元素
   ```

   性能为 `O(n)`，删除点后的所有元素需向前移动。

3. **清空整个向量**：

   ```cpp
   v.clear(); // 删除所有元素，释放存储的元素但保留容量
   ```

------

## 4. **`std::vector` 与复杂类型**

#### **4.1 元素类型的构造与析构**

- 如果元素类型是简单类型（如 `int`、`double`），则操作通常高效。

- 如果是复杂类型（如自定义类），

  ```
  std::vector
  ```

   会调用其构造函数、析构函数和赋值运算符。示例：

  ```cpp
  class MyClass {
  public:
      MyClass() { std::cout << "Constructed\n"; }
      ~MyClass() { std::cout << "Destroyed\n"; }
  };
  std::vector<MyClass> v(3); // 会调用 3 次构造函数
  ```

#### **4.2 避免不必要的初始化**

如果仅希望预留空间，而不想初始化元素，可以使用 `reserve()` 而不是传递参数构造：

```cpp
std::vector<MyClass> v;
v.reserve(5); // 不会调用构造函数
```

------



## 5. **C++11 的增强功能**

1. **移动语义支持**

   - ```
     std::vector
     ```

      支持移动语义，避免不必要的拷贝，提升性能：

     ```cpp
     std::vector<int> v1 = {1, 2, 3};
     std::vector<int> v2 = std::move(v1); // v1 的内容转移到 v2，v1 变为空
     ```

2. **初始化列表**

   - 支持通过初始化列表快速创建：

     ```cpp
     std::vector<int> v = {1, 2, 3};
     ```

3. **`emplace` 系列方法**

   C++11 引入了 `emplace` 系列方法，例如 `emplace_back` 和 `emplace`，用于在容器中直接构造元素。这些方法避免了传统 `push_back` 可能涉及的对象复制或移动操作，从而提高效率。

   **1. `emplace_back`**
   
   - 用于在容器末尾直接构造一个元素。
   - 与 `push_back` 的区别在于，`emplace_back` 会直接在容器的内存空间中调用元素的构造函数，而不是先创建一个临时对象然后复制或移动到容器中。
   
   ```cpp
   #include <vector>
   #include <string>
   #include <iostream>
   
   class MyClass {
   public:
       MyClass(int x, std::string y) {
           std::cout << "Constructed with " << x << " and " << y << "\n";
       }
   };
   
   int main() {
       std::vector<MyClass> v;
   
       // 使用 emplace_back 直接构造
       v.emplace_back(42, "Hello");
   
       return 0;
   }
   
   // 输出:
   // Constructed with 42 and Hello
   ```
   
    
   - `emplace_back(42, "Hello")` 直接在容器中构造了一个 `MyClass` 对象，避免了不必要的临时对象。
   
   **2. `emplace`**
   
   - 用于在容器的任意位置直接构造一个元素（通过迭代器指定位置）。
   - 适用于需要插入到特定位置的情况，与 `insert` 类似，但更加高效。
   
   ```cpp
   #include <vector>
   #include <string>
   #include <iostream>
   
   class MyClass {
   public:
       MyClass(int x, std::string y) {
           std::cout << "Constructed with " << x << " and " << y << "\n";
       }
   };
   
   int main() {
       std::vector<MyClass> v;
   
       // 使用 emplace_back 添加一个元素
       v.emplace_back(1, "First");
   
       // 使用 emplace 在指定位置插入
       v.emplace(v.begin(), 0, "Zero");
   
       return 0;
   }
   
   // 输出:
   // Constructed with 0 and Zero
   // Constructed with 1 and First
   ```
   
   - `v.emplace(v.begin(), 0, "Zero")` 在容器开头插入了一个元素，直接调用了 `MyClass` 的构造函数。
   
   **3. 区别：`emplace_back` vs `push_back`**
   
   | 特性         | `push_back`                    | `emplace_back`                       |
   | ------------ | ------------------------------ | ------------------------------------ |
   | **行为**     | 复制或移动对象到容器中         | 在容器内存中直接构造对象             |
   | **效率**     | 可能涉及额外的构造、复制或移动 | 更高效，避免额外的临时对象创建和拷贝 |
   | **适用场景** | 已有完整对象，直接插入         | 需要构造对象时直接插入               |
   
   

**`std::vector` 的限制**

- **连续内存需求**：由于所有元素存储在连续内存中，如果向量过大，可能会因内存碎片问题导致分配失败。
- **效率问题**：插入和删除操作（非末尾）效率较低，因此不适合频繁修改的场景。在这种情况下，`std::list` 或其他容器可能是更好的选择。

------

总结：
 `std::vector` 是一种功能强大且通用的容器，但要高效使用，需要了解其内存分配机制、迭代器失效规则以及性能特性。合理地使用 `reserve()`、避免不必要的初始化，并掌握 C++11 提供的新功能，可以显著提升程序性能并降低代码复杂度。



# 具体文章



## 向量的创建、拷贝和销毁

#### 向量的构造与析构

在 C++ 中，`std::vector` 是一种动态数组，提供了丰富的构造与析构操作。以下是向量的构造方式及其特点：

1. **默认构造函数：**

   ```cpp
   std::vector<int> vec;
   ```

   - 创建一个空向量，不包含任何元素。
   - 容量为 0。

2. **指定大小的构造函数：**

   ```cpp
   std::vector<int> vec(5);
   ```

   - 创建一个大小为 5 的向量，所有元素使用元素类型的默认构造函数进行初始化。
   - 对于基本数据类型（如 `int`），会被初始化为 0。

3. **指定大小和初始值：**

   ```cpp
   std::vector<int> vec(5, 10);
   ```

   - 创建一个大小为 5 的向量，每个元素的初始值为 10。

4. **使用迭代器范围的构造函数：**

   ```cpp
   std::vector<int> vec(other.begin(), other.end());
   ```

   - 根据另一个容器的迭代器范围，创建向量并拷贝该范围的所有元素。

5. **拷贝构造函数：**

   ```cpp
   std::vector<int> vec(other);
   ```

   - 创建一个向量，并拷贝另一个向量 `other` 的所有元素。

6. **移动构造函数（C++11 起）：**

   ```cpp
   std::vector<int> vec(std::move(other));
   ```

   - 转移另一个向量 `other` 的所有权，使其资源（如内存）直接归属新向量，效率更高，`other` 变为空。

7. **析构函数：**

   - 当向量超出作用域时，其析构函数会被调用，自动释放所有元素和相关内存资源。

------

### 向量的非修改操作

向量的非修改操作不会改变容器的内容，主要用于获取容器的状态或比较两个容器的内容。以下是这些操作的详细说明：

1. **空检查：**

   ```cpp
   vec.empty();
   ```

   - 返回布尔值，表示容器是否为空。
   - 等价于 `vec.size() == 0`，但效率可能更高。

2. **元素计数：**

   ```cpp
   vec.size();
   ```

   - 返回当前向量中元素的数量。

3. **最大大小：**

   ```cpp
   vec.max_size();
   ```

   - 返回向量理论上可以容纳的最大元素数量（由系统或实现限制）。

4. **容量：**

   ```cpp
   vec.capacity();
   ```

   - 返回向量当前的容量（即无需重新分配内存时可以容纳的最大元素数）。

5. **预留容量：**

   ```cpp
   vec.reserve(100);
   ```

   - 如果当前容量不足以容纳 `100` 个元素，则增加容量。
   - 注意，`reserve` 只影响容量，不改变大小（`size`）。

6. **调整容量：**

   ```cpp
   vec.shrink_to_fit();
   ```

   - 请求将容量调整为当前大小，释放多余的内存（C++11 引入）。
   - 注意，具体实现是否执行该操作并不保证。

7. **比较操作符：**
    向量支持以下比较操作：

   - `vec1 == vec2`：判断两个向量是否相等（逐元素比较）。
   - `vec1 != vec2`：判断两个向量是否不相等。
   - `vec1 < vec2`：按字典顺序判断是否小于 `vec2`。
   - `vec1 > vec2`：判断是否大于 `vec2`（等价于 `vec2 < vec1`）。
   - `vec1 <= vec2`：判断是否小于或等于 `vec2`。
   - `vec1 >= vec2`：判断是否大于或等于 `vec2`。

------

### 总结

1. **创建向量时，可以选择不同的初始化方式，灵活性强。**
2. **非修改操作提供了对向量状态和内容的快速查询，常用于逻辑判断。**
3. **了解向量的容量管理（如 `reserve` 和 `shrink_to_fit`）有助于优化性能，避免不必要的内存分配。**

## 向量的赋值操作 (Assignment Operations)

C++ 中的 `std::vector` 提供了多种赋值操作，用于用新的元素替换向量中的所有现有元素，同时调整大小以匹配新内容。这些操作的灵活性与构造函数类似，可以从多种来源进行赋值。以下是这些操作的详细说明：

------

### **赋值操作列表**

1. **拷贝赋值：**

   ```cpp
   c = c2;
   ```

   - 将向量 `c2` 的所有元素赋值给向量 `c`。
   - 如果目标向量 `c` 原本有内容，这些内容会被移除，然后用 `c2` 的内容填充。

2. **移动赋值（C++11 起）：**

   ```cpp
   c = std::move(rv);
   ```

   - 使用右值引用 `rv` 的内容赋值给向量 `c`，实现资源的转移。
   - 不进行深拷贝，效率更高。
   - 赋值后，`rv` 将变为空。

3. **初始化列表赋值（C++11 起）：**

   ```cpp
   c = {elem1, elem2, elem3};
   ```

   - 使用初始化列表为向量 `c` 赋值。

   - 示例：

     ```cpp
     std::vector<int> vec;
     vec = {1, 2, 3, 4};
     ```

4. **指定大小和元素的赋值：**

   ```cpp
   c.assign(n, elem);
   ```

   - 用 `n` 个值为 `elem` 的元素替换向量 `c` 中的所有内容。

   - 示例：

     ```cpp
     std::vector<int> vec;
     vec.assign(5, 10); // 向量大小为 5，所有元素为 10
     ```

5. **指定范围的赋值：**

   ```cpp
   c.assign(beg, end);
   ```

   - 使用迭代器范围 `[beg, end)` 的内容赋值给向量 `c`。

   - 示例：

     ```cpp
     std::list<int> lst = {1, 2, 3};
     std::vector<int> vec;
     vec.assign(lst.begin(), lst.end());
     // vec 的内容为 1, 2, 3
     ```

6. **初始化列表赋值（另一种形式）：**

   ```cpp
   c.assign({elem1, elem2, elem3});
   ```

   - 与直接赋值等效，但通过 `assign` 方法完成。

   - 示例：

     ```cpp
     std::vector<int> vec;
     vec.assign({1, 2, 3, 4});
     ```

7. **交换内容：**

   - **成员函数：**

     ```cpp
     c1.swap(c2);
     ```

     - 交换向量 `c1` 和 `c2` 的数据。

     - 示例：

       ```cpp
       std::vector<int> vec1 = {1, 2};
       std::vector<int> vec2 = {3, 4};
       vec1.swap(vec2);
       // vec1 为 {3, 4}，vec2 为 {1, 2}
       ```

   - **全局函数：**

     ```cpp
     swap(c1, c2);
     ```

     - 等效于 `c1.swap(c2)`。

------

### **赋值操作的特性**

1. **涉及的函数调用：**
   - 赋值操作可能调用：
     - **默认构造函数：** 用于初始化新创建的元素。
     - **拷贝构造函数：** 用于拷贝新元素。
     - **赋值操作符：** 用于将值赋给已有元素。
     - **析构函数：** 用于销毁被移除的元素。
2. **对资源的影响：**
   - 如果赋值操作会增加元素数量，则需要重新分配内存，并为新元素调用构造函数。
   - 如果赋值操作会减少元素数量，则调用析构函数释放多余的元素。
3. **资源安全：**
   - 移动赋值避免了不必要的深拷贝，是一种高效的操作，特别适用于大规模向量。

------

### **示例：从不同容器赋值**

以下示例展示了如何从不同类型的容器中赋值：

```cpp
#include <vector>
#include <list>
#include <iostream>

int main() {
    std::list<int> lst = {1, 2, 3, 4};
    std::vector<int> vec;

    // 使用迭代器范围赋值
    vec.assign(lst.begin(), lst.end());

    // 输出结果
    for (const auto& elem : vec) {
        std::cout << elem << " ";
    }
    return 0;
}
```

**输出：**

```
1 2 3 4
```

------

### 总结

1. **多种赋值方式让 `std::vector` 更加灵活，支持从范围、初始化列表或其他容器赋值。**
2. **对于性能敏感的场景，可以优先使用移动赋值，避免不必要的资源拷贝。**
3. **交换操作提供了一种高效的方式交换两个向量的数据，不会涉及元素的复制或移动。**

## 向量的元素访问

在 C++ 中，`std::vector` 提供多种方式访问其元素，包括范围循环、迭代器及直接访问操作。这些操作允许从向量中读取或修改元素，但需注意边界检查和空容器的情况。

------

### **直接元素访问操作**

表格 7.12 总结了所有用于直接访问 `std::vector` 元素的操作：

| 操作        | 功能说明                                                     |
| ----------- | ------------------------------------------------------------ |
| `c[idx]`    | 返回索引为 `idx` 的元素，不进行范围检查。                    |
| `c.at(idx)` | 返回索引为 `idx` 的元素，超出范围时抛出 `std::out_of_range` 异常。 |
| `c.front()` | 返回第一个元素，不检查容器是否为空。                         |
| `c.back()`  | 返回最后一个元素，不检查容器是否为空。                       |

------

### **具体操作说明**

1. **`operator[]`：索引访问**

   ```cpp
   c[idx];
   ```

   - 通过索引访问向量元素。

   - 不执行范围检查，索引越界会导致 **未定义行为**。

   - 示例：

     ```cpp
     std::vector<int> vec = {1, 2, 3};
     int value = vec[1]; // value = 2
     vec[1] = 10;        // 修改元素为 10
     ```

2. **`at()`：带范围检查的访问**

   ```cpp
   c.at(idx);
   ```

   - 功能与 `operator[]` 类似，但会检查索引是否在范围内。

   - 如果索引越界，会抛出 `std::out_of_range` 异常，避免未定义行为。

   - 示例：

     ```cpp
     std::vector<int> vec = {1, 2, 3};
     try {
         int value = vec.at(5); // 抛出异常
     } catch (const std::out_of_range& e) {
         std::cerr << "Error: " << e.what() << '\n';
     }
     ```

3. **`front()`：访问第一个元素**

   ```cpp
   c.front();
   ```

   - 返回向量的第一个元素，不检查向量是否为空。

   - 如果向量为空，调用会导致 **未定义行为**。

   - 示例：

     ```cpp
     std::vector<int> vec = {1, 2, 3};
     int first = vec.front(); // first = 1
     ```

4. **`back()`：访问最后一个元素**

   ```cpp
   c.back();
   ```

   - 返回向量的最后一个元素，不检查向量是否为空。

   - 如果向量为空，调用会导致 **未定义行为**。

   - 示例：

     ```cpp
     std::vector<int> vec = {1, 2, 3};
     int last = vec.back(); // last = 3
     ```

------

### **安全访问注意事项**

1. **范围检查：**

   - 仅 `at()` 提供了范围检查。对于 `operator[]`、`front()` 和 `back()`，需要调用者确保索引合法或容器非空。

   - 示例：

     ```cpp
     std::vector<int> vec;
     if (!vec.empty()) {
         std::cout << vec.front(); // 安全
     }
     ```

2. **空容器的访问：**

   - 对空容器调用 `front()` 或 `back()` 会导致 **未定义行为**。

   - 示例：

     ```cpp
     std::vector<int> vec;
     if (!vec.empty()) {
         int first = vec.front(); // OK
     }
     ```

3. **多线程环境：**

   - 在多线程环境中，需同步操作，确保在检查容器状态与访问元素之间容器未被修改。

   - 示例：

     ```cpp
     // 单线程中可行
     if (vec.size() > 5) {
         vec[5] = 42; // 安全
     }
     
     // 多线程中需加锁
     std::mutex mtx;
     std::lock_guard<std::mutex> lock(mtx);
     if (vec.size() > 5) {
         vec[5] = 42; // 安全
     }
     ```

------

### **小结**

1. **访问方式灵活：** 提供了 `operator[]` 和 `at()` 两种索引访问方式，适用于不同场景。
2. 需注意安全性：
   - 使用 `at()` 可避免越界访问问题。
   - 确保 `front()` 和 `back()` 不被空容器调用。
3. **多线程需同步：** 在多线程环境下需使用同步机制，确保访问的容器状态一致性。

通过正确使用这些操作，既可高效访问 `std::vector` 元素，也可避免潜在的运行时错误。

## 向量的插入和移除操作

`std::vector` 提供了丰富的插入和移除操作，用于动态修改其内容。这些操作可高效管理向量的大小和元素，支持从单个元素到范围的灵活操作。以下是表格 7.14 的详细解析。

------

### **插入操作**

1. **`push_back`：添加到末尾**

   ```cpp
   c.push_back(elem);
   ```

   - 在向量末尾添加一个元素 `elem` 的副本。

   - 如果需要扩容，会重新分配内存。

   - 示例：

     ```cpp
     std::vector<int> vec;
     vec.push_back(10); // vec = {10}
     ```

2. **`emplace_back`：在末尾原地构造（C++11 起）**

   ```cpp
   c.emplace_back(args...);
   ```

   - 在向量末尾直接构造元素，避免拷贝，效率更高。

   - 示例：

     ```cpp
     std::vector<std::pair<int, int>> vec;
     vec.emplace_back(1, 2); // 直接构造 pair，vec = {(1, 2)}
     ```

3. **`insert`：插入单个元素**

   ```cpp
   c.insert(pos, elem);
   ```

   - 在迭代器 `pos` 位置前插入一个元素 `elem` 的副本，返回新插入元素的位置。

   - 示例：

     ```cpp
     std::vector<int> vec = {1, 2, 3};
     vec.insert(vec.begin() + 1, 10); // vec = {1, 10, 2, 3}
     ```

4. **`insert`：插入多个元素**

   ```cpp
   c.insert(pos, n, elem);
   ```

   - 在迭代器 `pos` 位置前插入 `n` 个值为 `elem` 的元素，返回第一个新元素的位置。

   - 示例：

     ```cpp
     std::vector<int> vec = {1, 2, 3};
     vec.insert(vec.begin() + 1, 3, 10); // vec = {1, 10, 10, 10, 2, 3}
     ```

5. **`insert`：插入范围**

   ```cpp
   c.insert(pos, beg, end);
   ```

   - **将范围 `[beg, end)` 的元素插入到迭代器 `pos` 位置前。**

     ```cpp
     std::list<int> lst = {4, 5, 6};
     std::vector<int> vec = {1,          2, 3};
     vec.insert(vec.begin() + 1, lst.begin(), lst.end()); // vec = {1, 4, 5, 6, 2, 3}
     ```

6. **`insert`：插入初始化列表（C++11 起）**

   ```cpp
   c.insert(pos, initlist);
   ```

   - **将初始化列表中的所有元素插入到迭代器 `pos` 位置前。**

   - 示例：

     ```cpp
     std::vector<int> vec = {1, 2, 3};
     vec.insert(vec.begin() + 1, {10, 20, 30}); // vec = {1, 10, 20, 30, 2, 3}
     ```

7. **`emplace`：在指定位置原地构造（C++11 起）**

   ```cpp
   c.emplace(pos, args...);
   ```

   - 在迭代器 `pos` 位置前直接构造元素，返回新元素的位置。

   - 示例：

     ```cpp
     std::vector<std::pair<int, int>> vec;
     vec.emplace(vec.begin(), 1, 2); // 直接构造 pair，vec = {(1, 2)}
     ```

------

### **移除操作**

1. **`pop_back`：移除末尾元素**

   ```cpp
   c.pop_back();
   ```

   - 移除向量末尾的元素，但不返回其值。

   - 示例：

     ```cpp
     std::vector<int> vec = {1, 2, 3};
     vec.pop_back(); // vec = {1, 2}
     ```

2. **`erase`：移除指定位置的元素**

   ```cpp
   c.erase(pos);
   ```

   - 移除迭代器 `pos` 指定的元素，返回下一个元素的位置。

   - 示例：

     ```cpp
     std::vector<int> vec = {1, 2, 3};
     vec.erase(vec.begin() + 1); // vec = {1, 3}
     ```

3. **`erase`：移除范围内的元素**

   ```cpp
   c.erase(beg, end);
   ```

   - 移除范围 `[beg, end)` 内的所有元素，返回下一个元素的位置。

   - 示例：

     ```cpp
     std::vector<int> vec = {1, 2, 3, 4};
     vec.erase(vec.begin() + 1, vec.begin() + 3); // vec = {1, 4}
     ```

4. **`clear`：清空向量**

   ```cpp
   c.clear();
   ```

   - 移除所有元素，使向量变为空。

   - 示例：

     ```cpp
     std::vector<int> vec = {1, 2, 3};
     vec.clear(); // vec = {}
     ```

------

### **其他操作**

1. **`resize`：调整大小**

   ```cpp
   c.resize(num);
   c.resize(num, elem);
   ```

   - 改变向量的大小为 

     ```
     num
     ```

     - 如果向量变大，使用默认构造函数或提供的 `elem` 初始化新元素。
     - 如果向量变小，则移除多余的元素。

   - 示例：

     ```cpp
     std::vector<int> vec = {1, 2, 3};
     vec.resize(5);       // vec = {1, 2, 3, 0, 0}
     vec.resize(7, 10);   // vec = {1, 2, 3, 0, 0, 10, 10}
     vec.resize(2);       // vec = {1, 2}
     ```

2. **移除指定值的第一个元素**

   - 使用 

     ```
     find
     ```

      和 

     ```
     erase
     ```

     ：

     ```cpp
     std::vector<int> vec = {1, 2, 3, 2, 4};
     auto pos = std::find(vec.begin(), vec.end(), 2);
     if (pos != vec.end()) {
         vec.erase(pos); // vec = {1, 3, 2, 4}
     }
     ```

------

### **总结**

1. **插入操作：**
   - `push_back` 和 `emplace_back` 用于末尾添加。
   - `insert` 和 `emplace` 用于指定位置插入。
   - `emplace` 和 `emplace_back` 直接构造对象，效率更高。
2. **移除操作：**
   - `pop_back` 移除末尾。
   - `erase` 和 `clear` 用于移除指定元素或清空容器。
3. **灵活性：**
   - 通过范围插入和移除，能与其他容器（如 `std::list`）高效协作。
   - 使用 `find` 定位特定值，结合 `erase` 精确移除。

这些操作使得 `std::vector` 成为一个功能丰富、用途广泛的容器，适合动态数据管理场景。







## **向量的异常**

## **处理**

C++ 中的 `std::vector` 提供了对异常处理的基本支持，但其范围主要集中在内存分配失败或用户定义的操作可能引发的异常上。以下是关于向量异常处理的重要点和保证：

------

### **标准保证**

1. **`at()` 的异常处理：**

   - `at()` 是唯一一个标准明确要求可能抛出异常的成员函数。

   - 如果索引超出范围，会抛出 `std::out_of_range` 异常。

   - 示例：

     ```cpp
     std::vector<int> vec = {1, 2, 3};
     try {
         int value = vec.at(5); // 抛出异常
     } catch (const std::out_of_range& e) {
         std::cerr << "Out of range: " << e.what() << '\n';
     }
     ```

2. **内存分配失败：**

   - 如果内存不足，例如在插入操作中，可能抛出 `std::bad_alloc` 异常。

3. **用户定义类型的操作：**

   - 如果元素类型的拷贝、移动构造函数或赋值操作可能抛出异常，向量的某些操作也可能因此抛出异常。

------

### **标准库的行为保证**

以下是常见操作在异常处理中的行为保证：

1. **`push_back`：**

   - 如果 `push_back` 的过程中发生异常，该操作无任何效果。

   - 示例：

     ```cpp
     std::vector<std::string> vec;
     try {
         vec.push_back(std::string(1e9, 'a')); // 可能抛出 std::bad_alloc
     } catch (const std::bad_alloc&) {
         std::cerr << "Memory allocation failed\n";
     }
     ```

2. **`insert`、`emplace` 和 `emplace_back`：**

   - 如果拷贝或移动构造函数不抛出异常，这些操作要么成功，要么无效果。

   - 示例：

     ```cpp
     std::vector<int> vec = {1, 2, 3};
     try {
         vec.insert(vec.begin() + 1, std::numeric_limits<int>::max());
     } catch (...) {
         // 如果异常发生，向量内容不变
     }
     ```

3. **`pop_back`：**

   - 不会抛出任何异常。

4. **`erase`：**

   - 如果元素类型的拷贝或移动操作不抛出异常，`erase` 不会抛出异常。

5. **`swap` 和 `clear`：**

   - 这些操作保证不会抛出异常。

6. **元素类型不抛出异常的特殊保证：**

   - 如果向量的元素类型在拷贝和移动操作中从不抛出异常（例如普通数据类型 POD），向量的所有操作要么成功完成，要么无任何效果。

------

### **迭代器的有效性与异常**

1. **迭代器类型：**

   - 向量的迭代器是随机访问迭代器。
   - 通常是普通指针，但实现上可能是辅助类，例如在使用安全版本的 STL 时。

2. **迭代器的失效：**

   - 以下情况可能导致迭代器失效：
     - 插入或删除索引较小的元素。
     - 容量重新分配（reallocation）。

3. **保持迭代器有效：**

   - 如果元素类型不抛出异常，向量操作要么完成操作，要么无效果，迭代器状态一致。

   - 示例：

     ```cpp
     std::vector<int> vec = {1, 2, 3};
     auto it = vec.begin();
     vec.push_back(4); // 如果容量足够，`it` 保持有效；否则，`it` 失效
     ```

------

### **示例：异常处理与向量操作**

```cpp
#include <vector>
#include <iostream>
#include <stdexcept>

int main() {
    std::vector<int> vec = {1, 2, 3};

    // 安全访问
    try {
        std::cout << vec.at(5); // 抛出 std::out_of_range
    } catch (const std::out_of_range& e) {
        std::cerr << "Out of range error: " << e.what() << '\n';
    }

    // 内存分配失败
    try {
        vec.reserve(1e9); // 如果内存不足，抛出 std::bad_alloc
    } catch (const std::bad_alloc& e) {
        std::cerr << "Memory allocation failed\n";
    }

    // 插入操作的安全性
    try {
        vec.insert(vec.begin(), 10);
    } catch (...) {
        std::cerr << "Insertion failed\n";
    }

    return 0;
}
```

**输出可能为：**

```
Out of range error: vector::_M_range_check: __n (which is 5) >= this->size() (which is 3)
Memory allocation failed
```

------

### **总结**

1. **`std::vector` 的异常安全性：**
   - 操作通常是 “要么成功，要么无效果”，特别是在元素类型不抛出异常时。
   - 标准库提供了可靠的行为保证，即使在异常情况下也不会导致数据损坏。
2. **迭代器注意事项：**
   - 插入或删除操作可能使迭代器失效，需谨慎处理。
3. **最佳实践：**
   - 使用 `at()` 替代 `operator[]`，避免访问越界。
   - 处理可能的 `std::bad_alloc` 异常，特别是在内存受限的场景下。
   - 对多线程场景使用同步机制，避免迭代器失效或数据竞争。





### **C++ 向量 (std::vector) 的异常处理与操作总结**

------

#### **异常处理**

1. **标准支持：**

   - `at()`

      是唯一保证抛出异常的成员函数，用于安全访问元素：

     - 如果索引超出范围，会抛出 `std::out_of_range` 异常。

   - 常见异常：

     - **`std::bad_alloc`**：内存分配失败。
     - 用户定义的操作可能引发其他异常。

2. **操作的异常安全性：**

   - 插入操作 (`push_back`, `insert`, `emplace`, `emplace_back`)：
     - 如果异常发生，这些操作 **无任何效果**。
   - 删除操作 (`pop_back`, `erase`)：
     - **`pop_back()`** 不抛出异常。
     - **`erase()`** 不抛出异常，前提是元素类型的拷贝/移动操作不抛出。
   - `swap` 和 `clear`：
     - 保证不会抛出异常。
   - 如果元素类型的拷贝/移动操作不抛出异常，所有操作要么成功完成，要么无任何效果。

3. **异常安全的元素：**

   - 若使用的元素类型不抛出异常（如 POD 类型），向量的所有操作都可保证异常安全。
   - POD（Plain Old Data）：没有构造函数、析构函数或其他特殊特性，例如 C 风格的结构体。

4. **要求：**

   - 向量的析构函数 **不应抛出异常**，以确保资源能被正常释放。

------

#### **赋值操作**

表 7.11 列出了向量支持的赋值操作，这些操作类似于构造函数：

| **操作**                        | **效果**                                                   |
| ------------------------------- | ---------------------------------------------------------- |
| `c = c2`                        | 拷贝赋值，使用向量 `c2` 的所有元素覆盖向量 `c`。           |
| `c = rv`                        | 移动赋值，将右值 `rv` 的内容移动到 `c` 中（自 C++11 起）。 |
| `c = initlist`                  | 使用初始化列表中的元素覆盖向量 `c`（自 C++11 起）。        |
| `c.assign(n, elem)`             | 使用 `n` 个值为 `elem` 的元素覆盖向量 `c` 的内容。         |
| `c.assign(beg, end)`            | 使用迭代器范围 `[beg, end)` 的元素覆盖向量 `c` 的内容。    |
| `c.assign(initlist)`            | 使用初始化列表中的元素覆盖向量 `c` 的内容（自 C++11 起）。 |
| `c1.swap(c2)` 或 `swap(c1, c2)` | 交换向量 `c1` 和 `c2` 的内容，不抛出异常。                 |

------

#### **迭代器操作**

表 7.13 列出向量支持的迭代器操作：

- 向量的迭代器是 **随机访问迭代器**，支持 STL 的所有算法。
- 常见操作：
  - `begin()` 和 `end()`：返回向量的起始和结束迭代器。
  - `cbegin()` 和 `cend()`：返回只读迭代器（C++11 起）。
  - 迭代器通常实现为普通指针，但某些实现中可能是辅助类。

**迭代器有效性：**

- 如果插入或删除了索引较小的元素，或者发生了重新分配（容量变化），迭代器会失效。
- 需要谨慎管理迭代器的生命周期。

------

#### **插入与删除操作**

表 7.14 列出了插入和删除操作的详细信息：

| **操作**                  | **效果**                                                     |
| ------------------------- | ------------------------------------------------------------ |
| `c.push_back(elem)`       | 在向量末尾添加元素 `elem` 的副本，可能触发内存分配。         |
| `c.emplace_back(args...)` | 在向量末尾原地构造元素，避免拷贝，效率更高（自 C++11 起）。  |
| `c.insert(pos, elem)`     | 在迭代器 `pos` 位置前插入元素 `elem` 的副本，返回新元素的位置。 |
| `c.insert(pos, n, elem)`  | 在 `pos` 位置前插入 `n` 个值为 `elem` 的元素。               |
| `c.insert(pos, beg, end)` | 在 `pos` 位置前插入范围 `[beg, end)` 的所有元素。            |
| `c.insert(pos, initlist)` | 在 `pos` 位置前插入初始化列表中的所有元素（自 C++11 起）。   |
| `c.emplace(pos, args...)` | 在迭代器 `pos` 位置前原地构造元素（自 C++11 起）。           |
| `c.pop_back()`            | 移除末尾元素，不返回其值，不抛出异常。                       |
| `c.erase(pos)`            | 移除迭代器 `pos` 指向的元素，返回下一个元素的位置。          |
| `c.erase(beg, end)`       | 移除范围 `[beg, end)` 内的所有元素，返回下一个元素的位置。   |
| `c.resize(num)`           | 调整向量大小为 `num`，新增的元素使用默认构造函数初始化。     |
| `c.resize(num, elem)`     | 调整向量大小为 `num`，新增的元素为 `elem` 的副本。           |
| `c.clear()`               | 移除所有元素，不抛出异常，向量变为空。                       |

**示例：移除特定值的第一个元素**

```cpp
std::vector<int> coll = {1, 2, 3, 4, 2};
auto pos = std::find(coll.begin(), coll.end(), 2);
if (pos != coll.end()) {
    coll.erase(pos); // 移除第一个值为 2 的元素
}
// coll = {1, 3, 4, 2}
```

------

#### **最佳实践**

1. **安全访问：**
   - 使用 `at()` 替代 `operator[]`，确保不会越界访问。
2. **异常处理：**
   - 处理可能的 `std::bad_alloc` 异常，特别是在内存受限场景中。
   - 保证元素的析构函数不抛出异常。
3. **迭代器有效性：**
   - 插入或删除操作后，应重新获取迭代器。
4. **性能优化：**
   - 使用 `emplace_back` 和 `emplace` 直接构造元素，避免不必要的拷贝。

------

通过正确处理异常、管理迭代器及选择合适的操作，可以充分发挥 `std::vector` 的灵活性和高效性，同时避免潜在的运行时问题。